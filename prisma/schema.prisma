// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  STUDENT
}

enum QuestionType {
  MULTIPLE_CHOICE
  OPEN_TEXT
  CODE_SQL
}

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  name          String
  role          UserRole  @default(STUDENT)
  createdAt     DateTime  @default(now())
  
  // Relaciones
  examsCreated  Exam[]    @relation("CreatedExams")
  attempts      ExamAttempt[]
}

model Exam {
  id              String    @id @default(uuid())
  title           String
  description     String?
  accessCode      String    @unique // El código tipo "DB2025"
  startTime       DateTime?
  endTime         DateTime?
  timeLimitMin    Int?      // Tiempo límite en minutos
  isActive        Boolean   @default(false)
  
  createdById     String
  createdBy       User      @relation("CreatedExams", fields: [createdById], references: [id])
  
  questions       Question[]
  attempts        ExamAttempt[]
}

model Question {
  id          String       @id @default(uuid())
  examId      String
  exam        Exam         @relation(fields: [examId], references: [id], onDelete: Cascade)
  content     String       // El texto de la pregunta
  type        QuestionType
  points      Int          @default(1)
  order       Int          @default(0)
  
  options     Option[]
  answers     Answer[]
}

model Option {
  id          String    @id @default(uuid())
  questionId  String
  question    Question  @relation(fields: [questionId], references: [id], onDelete: Cascade)
  text        String
  isCorrect   Boolean   @default(false)
  
  answers     Answer[]  // Relación inversa para saber qué alumnos escogieron esto
}


model ExamAttempt {
  id          String    @id @default(uuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id])
  examId      String
  exam        Exam      @relation(fields: [examId], references: [id])
  
  startedAt   DateTime  @default(now())
  finishedAt  DateTime?
  score       Float?
  
  // AGREGA ESTA LÍNEA:
  status      String    @default("in_progress") 
  
  answers     Answer[]
}
model Answer {
  id               String       @id @default(uuid())
  attemptId        String
  attempt          ExamAttempt  @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  
  questionId       String
  question         Question     @relation(fields: [questionId], references: [id])
  
  // Si es opción múltiple:
  selectedOptionId String?
  selectedOption   Option?      @relation(fields: [selectedOptionId], references: [id])
  
  // Si es texto o SQL:
  textAnswer       String?
  
  isCorrect        Boolean?     // Calculado
  pointsAwarded    Int          @default(0)

  // Un constraint único: Un intento solo puede tener una respuesta por pregunta
  @@unique([attemptId, questionId])
}